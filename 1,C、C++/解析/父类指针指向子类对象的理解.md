父类子类指针函数调用注意事项
1，如果以一个基础类指针指向一个衍生类对象(派生类对象)，那么经由该指针只能访问基础类定义的函数（静态联翩）

2，如果以一个衍生类指针指向一个基础类对象，必须先做强制转型动作（explicit cast），这种做法很危险，也不符合生活习惯，在程序设计上也会给程序员带来困扰。（一般不会这么去定义）

3，如果基础类和衍生类定义了相同名称的成员函数，那么通过对象指针调用成员函数时，到底调用那个函数要根据指针的原型来确定，而不是根据指针实际指向的对象类型确定。

虚拟函数就是为了对“如果你以一个基础类指针指向一个衍生类对象，那么通过该指针，你只能访问基础类定义的成员函数”这条规则反其道而行之的设计。

如果你预期衍生类由可能重新定义一个成员函数，那么你就把它定义成虚拟函数（ virtual ）。
polymorphism就是让处理基础类别对象的程序代码能够通透的继续适当地处理衍生类对象。

纯虚拟函数：
virtual void myfunc ( ) =0;
纯虚拟函数不许定义其具体动作，它的存在只是为了在衍生类钟被重新定义。只要是拥有纯虚拟函数的类，就是抽象类，它们是不能够被实例化的（只能被继承）。如果一个继承类没有改写父类中的纯虚函数，那么他也是抽象类，也不能被实例化。
抽象类不能被实例化，不过我们可以拥有指向抽象类的指针，以便于操纵各个衍生类。
虚拟函数衍生下去仍然是虚拟函数，而且还可以省略掉关键字“virtual”。

看个例子：
#include <iostream> 
using namespace std; 
class A 
{ 
public: 
    virtual void foo() 
    { 
        cout << "A's foo()" << endl; 
        bar(); 
    } 
    virtual void bar() 
    { 
        cout << "A's bar()" << endl; 
    } 
}; 
class B: public A 
{ 
public: 
    void foo() 
    { 
        cout << "B's foo()" << endl; 
        A::foo(); 
    } 
    void bar() 
    { 
        cout << "B's bar()" << endl; 
    } 
}; 
int main() 
{ 
    B bobj; 
    A *aptr = &bobj; 
    aptr->foo(); 
    A aobj = *aptr; //转化为A类对象
    aobj.foo(); 
}

aptr->foo()输出结果是：
   B's foo()//这个明白，多态性
   A's foo()//这个也明白,执行A::foo();
   B's bar()//虽然调用的是这个函数:A::foo(); 但隐式传入的还是bobj 的地址,所以再次调用bar();调用时还是会调用B的函数, 与虚函数指针有关

aobj.foo()输出结果是：
  A's foo() //这个不是指针,aobj完全是一个A的对象,与多态没有关系
  A's bar() 
