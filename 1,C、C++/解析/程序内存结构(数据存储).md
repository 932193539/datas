//code1
char* toStr() 
{
    char *s = "abcdefghijkl";
    return s;
}
int main()
{
    cout << toStr() << endl;
    return 0;
}

//code2
char* toStr() 
{
    char s[] = "abcdefghijkl";
    return s;
}
int main()
{
    cout << toStr() << endl;
    return 0;
}
两段代码都很简单，输出一段字符，类型不同，一个是char*字符串，一个是char[]数据。
结果：第一个正确输出，第二个输出乱码。
原因：在于局部变量的作用域和内存分配的问题，第一char*是指向一个常量，作用域为函数内部，被分配在程序的常量区，直到整个程序结束才被销毁，所以在程序结束前常量还是存在的。而第二个是数组存放的，作用域为函数内部，被分配在栈中，就会在函数调用结束后被释放掉，这时你再调用，肯定就错误了。

内存结构大致可分为五大区
栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
未初始化数据段(BSS段)：存放程序中未初始化的全局变量和静态变量的一块内存区域
数据段：该段包含了在程序中明确被初始化的全局变量、静态变量(包括全局静态变量和局部静态变量)和常量数据。
代码区：存放函数体的二进制代码。也有可能包含一些只读的常数变量


内存也可以分为两种属性
静态分配内存：是在程序编译和链接时就确定好的内存。 
动态分配内存：是在程序加载、调入、执行的时候分配/回收的内存。（貌似只有堆是这样的）


关于分配内存的方法?

malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。
　　










