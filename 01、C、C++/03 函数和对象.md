静态多态性:也叫编译时的多态性，是通过函数的重载来实现的
动态多态性:是在程序运行过程中才能动态的确定操作所针对的对象的,也叫运行时的多态性。

C++中的虚函数作用是允许在派生类中重新定义与基类同名的函数，并可以通过基类指针或引用来访问基类和派生类中同名的函数
当一个成员函数被命为虚函数，则派生类中同名的函数都被自动成为虚函数

动态多态性代码
#include <iostream>
#include <string>
using namespace std;
class animal
{
public:
 void sleep()
 {
  cout << "animal sleep\n" << endl;
 }
 virtual void breathe()
 {
  cout << "animal breathe\n" << endl;
 }
};
class fish : public animal
{
public:
 void breathe()
 {
  cout << "fish bubble\n" << endl;
 }
 void sleep()
 {
  cout << "fish sleep\n" << endl;
 }
};
int main()
{
 fish	fh;
 animal *pAn = new animal();
 pAn->breathe();
 pAn->sleep();
 pAn = &fh;
//派生类对象可以为基类对象的引用进行初始化或引用
 pAn->breathe();
//由于sleep不是虚函数，所以无法实现函数多态性
 pAn->sleep();
 return(0);
}

fish   *pFh;
animal ani;
pFh = &ani;
//基类对象不可以为派生类对象的引用进行初始化或引用 ,派生类可能会有自己的成员函数和成员变量(会报错)


函数参数有直接变量(如int、char、double等)类型、指针类型和引用类型。
如果参数是变量，传递方式是传值，就是将实参的值复制(复制，意味着空间消耗和时间消耗)到“栈”空间中。
如果参数是指针，传递方式是传址，需将指针复制(同样也消耗空间和时间，对于数组而言，只需存储数组首地址)到“栈”空间中。
如果是引用，则既不是传值，也不是传址，主调函数和被调函数共享参数的存放地址，与全局变量共享方式相同。
对于拷贝(复制)构造函数而言，类对象通常需要较多的存储空间，如果按值传递，必然会较大消耗“栈”空间，也需要较多的时间实施复制过程。因为复制构造函数不会修改参数的内容，也不会修改参数的属性，所以构造函数的参数应该是常量引用传递，如
ClassName(const ClassName &obj)


有时在基类中将某一成员函数定义为虚基类但是又不是基类本身的需要，而是为派生类考虑预留的函数名，方便实现多态性
这样我们可以定义纯虚函数在声明虚函数时被"初始化"为0的函数。
形如 virtual float area() const = 0;
凡是包含纯虚函数的类都称作抽象类。

包含纯虚函数的抽象类不能建立对象
C++没有接口一说也没有关于接口的关键字，但是如果抽象类中全部都是纯虚函数的话，那么它也可算作是一个接口


虚基类
当在多条继承路径上有一个公共的基类,在这些路径中的某几条汇合处，这个公共的基类就会产生多个实例(或多个副本)，若只想保存这个基类的一个实例，可以将这个公共基类说明为虚基类。

类不是一个实体，是一个抽象数据类型，它不占用内存空间




