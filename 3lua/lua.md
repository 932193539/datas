1.lua 流程

虽然我们把Lua当作解释型语言，但是Lua会首先把代码预编译成中间码然后再执行（很多解释型语言都是这么做的）。在解释型语言中存在编译阶段听起来不合适，然而，解释型语言的特征不在于他们是否被编译，而是编译器是语言运行时的一部分，所以，执行编译产生的中间码速度会更快。
dofile读入文件编译并执行，真正完成功能的函数是loadfile loadfile仅仅是编译代码成中间码，并且把编译后的chunk作为函数返回
程序员编码lua文件->语法词法分析生成Lua的字节码文件(对应Lua工具链的Luac.exe)->Lua解释器解析字节码，并执行其中的指令集->输出结果。
Lua编译器。它把用Lua语言编写的程序翻译为二进制luac文件
Lua与Python一样，可以被定义为脚本型的语言，与Python生成pyc字节码一样，Lua程序也有自己的字节码格式luac。Lua程序在加载到内存中后，Lua解释器环境会将其编译为Luac字节码，因此，加载本地的Luac字节码与Lua源程序一样，在内存中都是编译好的二进制结构。 c++运行生成exe文件，然后执行exe程序。exe文件里面其实存放着c代码对应的机器指令，执行exe就是调度cpu去一句句执行机器指令。
lua与c语言不同的地方在于，lua不需要生成exe文件，可以由lua解释器执行lua代码文件。lua解释器用c语言编写，执行代码时先将lua文件转换成字节码指令，然后再逐个执行字节码指令。
举个例子，lua源文件如下：
local a=18
local b=a
对应的字节码指令为：
; (1)  local a=18
[1] loadk      0   0        ; 18
; (2)  local b=a
[2] move       1   0
[3] return     0   1
这种指令称之为三地址指令，即1个操作码和2~3个参数组成一条指令。解释器每次取出一条指令，可以顺序往下执行，也可以跳行执行，比如从指令1直接跳到指令3，跳行执行一般用于if等条件语句。
解释器内部流程
解释器的输入就是源码文件，输出是代码执行结果。内部流程分为以下几个环节：
读取文件：一个代码文件作为一个长字符串读入。
词法分析：根据lua语法进行简单的单词切分，每个单词称为token，token有多个类型，比如 "local a=18"可以拆分为local、a、=、18这4个token，对应的类型分别为“保留字”、“变量”、“等号”、“数字”。
语法分析：检查是否满足lua语法，比如 function要以end结束，若发现有语法错误，立即报错停止执行。
生成中间字节码：若满足语法规则，可生成对应的字节码，比如 “local a=18”对应的字节码为 “loadk 0 0”，第一个0表示变量a所在的位置，第2个0表示常量18所在的位置，即将常量18赋给变量a。
执行字节码：生成字节码列表后，从第一行开始逐行执行，根据字节码的opcode执行对应的逻辑。
简单的说就是：
源码文件 -> 中间字节码 -> 解释器执行字节码

2.Lua 协同程序（类似多线程）

Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。
协同是非常强大的功能，但是用起来也很复杂。
线程和协同程序区别
线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。
在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。
协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同。

具体见 http://www.runoob.com/lua/lua-garbage-collection.html

3.Lua 垃圾回收

Lua 采用了自动内存管理。Lua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。

垃圾回收的目的是要释放掉不再被使用变量所占用的内存。

Lua的垃圾收集机制使用了名为标志和清扫(Mark-and-Sweep)的方式。默认情况下，所有变量都标记为“可回收”，回收是从根节点_G出发，可达的对象标记为“不可回收”，然后回收没有被标记为“不可回收”的变量。

一 回收机制

基础的Mark-and-Sweep(标记-清除算法)是最古老的解决循环引用情况垃圾收集算法之一。
顾名思义，这是一个two phases的算法，可用很简单的文字描述：
(1)Mark phase(标志阶段)
1> 每个可被gc的对象都拥有一个标志位，初始为0(unmarked)。
2> 定义程序中第一层可访问的对象集合为 根对象集合(root set)。
3> 递归遍历根集合中所有对象的引用关系，如果某对象标志位为unmarked，
则标志为1(marked)。

(2)Sweep phase(清扫阶段)
1> 遍历所有现存的对象：将标志位还是unmarked的对象释放；
同时将标志为marked的对象重新标志为unmarked，为下次gc做准备。

二 回收函数
1 相关功能
collectgarbage函数提供了多项功能：
停止垃圾回收；
重启垃圾回收；
强制执行一次回收循环；
强制执行一步垃圾回收；
获取Lua占用的内存；
以及两个影响垃圾回收频率和步幅的参数。

2 函数原型：
collectgarbage(opt,[,arg])

3 参数说明：
"stop" 停止垃圾收集器，如果它的运行。
"restart" 如果垃圾收集器已经停止，将重新启动它。
"collect" 执行一次全垃圾收集循环，默认执行此操作。
"count" 返回当前Lua中使用的内存量(以KB为单位)
"step" 单步执行一个垃圾收集。
步长 "Size" 由参数arg指定　(大型的值需要多步才能完成)，
如果要准确指定步长，需要多次实验以达最优效果。
如果步长完成一次收集循环，将返回True。
"setpause" 设置 arg/100 的值作为暂定收集的时长，并返回设置前的值。默认为200。
控制了收集器在开始一个新的收集周期之前要等待多久。 随着数字的增大就导致收集器工作工作的不那么主动。 小于 1 的值意味着收集器在新的周期开始时不再等待。 当值为 2 的时候意味着在总使用内存数量达到原来的两倍时再开启新的周期。
"setstepmul" 设置 arg/100 的值。
作为步长的增幅(即新步长=旧步长*arg/100);并返回设置前的值。默认为200。
控制了收集器的工作速度，这个速度是一个相对于内存分配的速度。
更大的数字将导致收集器工作的更主动的同时，也使每步收集的尺寸增加。
小于 1 的值会使收集器工作的非常慢，可能导致收集器永远都结束不了当前周期。
缺省值为200%，这意味着收集器将以内存分配器的两倍速运行。





