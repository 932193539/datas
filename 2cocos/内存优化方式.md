按照纹理size从大到小的顺序加载纹理
JPG不论在加载速度和内存消耗方面都很差。所以，千万不要使用JPG！
不要使用JPG图片！
假设，你有一个占内存16MB的纹理和四个占用内存4MB的纹理。如果你首先加载4MB的纹理，这个程序将会使用16MB的内存，而当它加载第四张纹理的时候，短时间内会飙到20MB。这时，你要加载16MB的那个纹理了，内存会马上飙到48MB（4*4 + 16*2），然后再降到32MB（4*4 + 16）。
忽视文件图片大小
图片文件和纹理的关系与此类似。图片文件大多是压缩过的，它们被使用的话必须先解压缩，然后才能会GPU所处理，变成我们熟知的纹理。一个2048*2048的png图片，采用32位颜色深度编码，那么它在磁盘上占用空间只有2MB。但是，如果变成纹理，它将消耗16MB的内存！
预先加载所有的纹理
就像标题所说，尽你所能，一定要预先加载所有的纹理。如果你的所有的纹理加起来不超过80MB内存消耗的话（指的是拥有Retina显示的设备，非Retina的减半考虑），你可以在第一个loading场景的时候就全部加载进来。
按照纹理size从大到小的顺序加载纹理
由于加载纹理时额外的内存消耗问题，所以，采用按纹理size从大到小的方式来加载纹理是一个最佳实践。
假设，你有一个占内存16MB的纹理和四个占用内存4MB的纹理。如果你首先加载4MB的纹理，这个程序将会使用16MB的内存，而当它加载第四张纹理的时候，短时间内会飙到20MB。这时，你要加载16MB的那个纹理了，内存会马上飙到48MB（4*4 + 16*2），然后再降到32MB（4*4 + 16）。
但是，反过来，你先加载16MB的纹理，然后短时候内飙到32MB。然后又降到16MB。这时候，你再依次加载剩下的4个4MB的，这时，最多会彪到（4*3 + 4*2 + 16=36）MB。
在这两种情况下，内存的峰值使用相差12MB，要知道，可能就是这12MB会断送你的游戏进程的小命哦！
使用一个Loading 场景
如果你不能预先加载所有的纹理的话，你可以使用一个loading场景，同时显示一个动画来表明加载的进度。这样可以在进入下一个场景之前，让前面一个场景销毁，同时释放它所占用的内存资源。
实现起来非常简单。这个loading场景调度一个selector，然后每一帧（或者0.1秒也可以）执行一个函数，比如update。除非你前面一个场景有内存泄漏，否则的话，每一次update函数执行的时候，都会把一些引用计数为0的内存资源释放掉。在这个update方法里面，你可以创建新的场景。
这样极大地避免了“间歇性内存飙高”的问题，可以极大地减小内存压力。
移除未使用的资源文件
在开发游戏的过程中，你会经常添加、移除和替换游戏资源。所以，你可能会因为某些原因，忘记移除一些不用的图片资源。所以，你需要额外注意把它们都从项目中移除出去，至少要从程序的target中出去。
尤其是你使用多个target的时候（比如，你同时维护ipad和mac版本），你就极有可能会在一个target里面添加一些错误的资源。
当然，在移除资源之后，你一定要充分测试你的游戏。切记！一定要充分测试。

